/** \page CMakeUsage CMake Usage

### Adding new source subdirectories and/or files

Compilation of source files is taken care of semi-automatically by our CMake infrastructure.
Developers do not need to worry about listing header and/or source files to be built in any
CMakeLists.txt\n
This said, a couple of gotchas have to be stressed. As already pointed out the CMake infrastructure
is only semi-automatic and cannot cope correctly with addition of new subdirectories under the main
source directory src/ or addition of new header and/or source files in an existing subdirectory.

#### New subdirectory
First of all, you will have to let CMake know that a new source-containing subdirectory
has been added to the source tree. Due to the hierarchical approach CMake is based upon
you will need to modify the CMakeLists.txt in the src directory and create a new one in
your new subdirectory.
For the first step:
	1. if your new subdirectory contains header files, add a line like the following
	to the CMakeLists.txt file contained in the src directory:
	\code
	    ${CMAKE_CURRENT_SOURCE_DIR}/subdir_name
	\endcode
	to the command setting the list of directories containing headers.
	This sets up the list of directories where CMake will look for headers with definitions
	of classes and functions. If your directory contains Fortran code you can skip this step;
	2. add a line like the following to the CMakeLists.txt file contained in the src directory:
	\code
	    add_subdirectory(subdir_name)
	\endcode
	This will tell CMake to go look inside subdir_name for a CMakeLists.txt containing
	more sets of instructions.
	It is preferable to add these new lines in **alphabetic order**

Inside your new subdirectory you will need to add a CMakeLists.txt file containing
the set of instructions to build your cutting edge code. This is the second step. 
There are a number of macros defined to help you write a fairly compact set of
instructions for CMake. Each source subdirectory is the lowest possible in the CMake
hierarchy and it contains set of instructions for:
	-# exporting a list of header files (.h or .hpp) to the upper level in the
	hierarchy, possibly excluding some of them
	-# define which headers are to be included in the Interface.hpp file via 
	the automatically generated Includer.hpp file
	-# exporting a list of source files (.c, .cpp, .F, .f, .F90, .f90) to the upper 
	level in the hierarchy, possibly excluding some of them
	-# adding a target for the creation of a static library to be used in the
	unit tests
	-# define install targets for the files in this subdirectory	

The CMakeLists.txt will differ based on the language of your source code.
	- for C/C++ use the following template:
	\code{.txt}
        set(headers_list "")
        # Get headers with .hpp extension
        get_hpp_headers(headers_list)
        # If you want to remove some headers specify them explictly here
        list(REMOVE_ITEM headers_list "")
        # Sort alphabetically
        list(SORT headers_list)
        set(to_includer "${headers_list}")
        # Write headers to Includer.hpp
        file(APPEND "${PROJECT_BINARY_DIR}/include/Includer.hpp" "// Green's functions\n")
        list(REMOVE_ITEM to_includer "DerivativeTypes.hpp" "ForIdGreen.hpp")
        write_to_Includer("${to_includer}")
        
        set(sources_list "")
        # Get sources with .cpp extension
        get_cpp_sources(sources_list)
        # If you want to remove some sources specify them explictly here
        list(REMOVE_ITEM sources_list "")
        
        if(ENABLE_TESTS)
        	add_library(green ${sources_list})
        	add_dependencies(green metal libtaylor)
        	install(TARGETS green ARCHIVE DESTINATION lib)
        endif()
        
        # Export the sources up to src directory level
        set(local_sources "")
        foreach(source ${sources_list})
        	get_filename_component(sourcepath ${source} ABSOLUTE)
        	list(APPEND local_sources ${sourcepath})
        endforeach()
        set(SOURCES ${local_sources} ${SOURCES} PARENT_SCOPE)
        
        # Sets install directory for all the headers in the list
        install_list_FILES("${headers_list}" include)
	\endcode
	- for Fortran use the following template:
	\code{.txt}
        set(sources_list "")
        # Get sources with Fortran extension
        get_fortran_sources(sources_list)
        # If you want to remove some sources specify them explictly here
        list(REMOVE_ITEM sources_list "")
        
        if(ENABLE_TESTS)
        	add_library(pedra ${sources_list})
        	install(TARGETS pedra ARCHIVE DESTINATION lib)
        endif()
        
        # Export the sources up to src directory level
        set(local_sources "")
        foreach(source ${sources_list})
        	get_filename_component(sourcepath ${source} ABSOLUTE)
          	set(local_sources ${sourcepath} ${local_sources})
        endforeach()
        set(SOURCES ${local_sources} ${SOURCES} PARENT_SCOPE)
	\endcode
		 

#### New source/header files
The fairly compact structure of each CMakeLists.txt file has a drawback each developer must
be aware of. Basically, there is no need for explictly listing source/header files because
internally CMake performs a globbing operation given the extensions of the files to target.
The drawback of this strategy is that the globbing is performed only when initially configuring
the project: adding new files does not trigger a new globbing.
If, however, the CMakeLists.txt of the directory where the file has been added is touched,
CMake triggers a new globbing. So the workaround to this partial drawback is to touch all
CMakeLists.txt in the project tree. This is achieved by using the touch_cmakelists Python
script found in build/bin (build is the name chosen for the build directory)
If you add new files *before* configuring the project there is no need to invoke touch_cmakelists
prior to building.
*/
