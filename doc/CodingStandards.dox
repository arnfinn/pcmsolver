/** \page CodingStandards Coding Standards

General Object-Oriented design principles you should try to follow \cite Sutter2004, \cite Cline1998, \cite CppFAQs :
        1. Identify the aspects of your application that vary and separate them from what stays the same;
        2. Program to an interface, not an implementation;
        3. Favor composition over inheritance;
        4. Strive for loosely coupled designs between objects that interact;
        5. Classes should be open for extension, but closed for modification;
        6. Depend upon abstractions. Do not depend upon concrete classes;
        7. Principle of Least Knowledge. Talk only to your immediate friends;

### Including header files

Do not include header files unnecessarily. Even if PCMSolver is not a big project, unnecessary include directives and/or forward declarations
introduce nasty interdependencies among different parts of the code.
This reflects mainly in longer compilation times, but also in uglier looking code (see also the discussion in \cite Sutter1999).

Follow these guidelines to decide whether to include or forward declare:
        1. class A makes no reference to class B. Neither include nor forward declare B;
        2. class A refers to class B as a friend. Neither include nor forward declare B;
        3. class A contains a pointer/reference to a class B object. Forward declare B;
        4. class A contains functions with a class B object (value/pointer/reference) as parameter/return value. Forward declare B;
        5. class A is derived from class B. include B;
        6. class A contains a class B object. include B.

\code{.cpp}

    #ifndef MYCLASS_HPP
    #define MYCLASS_HPP

    //==============================
    // Forward declared dependencies
    class Foo;
    class Bar;

    //==============================
    // Included dependencies
    #include <vector>
    #include "Parent.hpp"

    //==============================
    // The actual class
    class MyClass : public Parent         // Parent object, so #include "Parent.h"
    {
        public:
                std::vector<int> avector; // vector object, so #include <vector>
                Foo * foo;                // Foo pointer, so forward declare
                void Func(Bar & bar);     // Bar reference as parameter, so forward declare

                friend class MyFriend;    // friend declaration is not a dependency
                                          //    don't do anything about MyFriend
    };

    #endif // MYCLASS_HPP
\endcode

### Use of C++11

Despite the fact that C++11 is a much, much better language than C++98/C++03 we
cannot yet impose the requirement of a fully C++11 compliant compiler.
The CMake infrastructure is able to gather from the compiler which features from the
new standard are available, setting useful compiler definitions that enable
workaround code in the `Cxx11Workarounds.hpp` header file.
This header is automatically included in the general Config.hpp header, included
in every header and source file in the library.
The rules behind the workarounds are:
        1. Provide wrappers under `namespace pcm` for constructs/functions that were
        implemented in Boost prior to the new standard. Among others:
            -# `boost::function`
            -# `boost::bind`
            -# `boost::tuple`
            -# `boost::shared_ptr`
        2. Do **NOT** use new language constructs, unless a proper wrapper has been provided,
        either in the form of a macro or an _ad hoc_ implementation. Among others:
            -# `auto`
            -# variadic templates
            -# `static_assert`
            -# lambda functions
        For the `final`, `override` and `noexcept` keywords it is possible, for example,
        to provide a macro that expands to the appropriate token. Use them as they provide
        excellent form of code documentation!
        3. Do **NOT** use new standard headers, unless a proper wrapper has been provided.
        If a Boost counterpart exists, but requires linking against a library, think hard
        how to workaround the dependency!
        Among others:
            -# `<mutex>`
            -# `<regex>`
        4. Use of range-based `for` loops is **forbidden*, use `BOOST_FOREACH` instead.
        5. If your piece of code cannot make without a C++11 feature make sure that it can
        be easily disabled at the CMake level, as it is done, e.g. for the logger and timer
        classes.

### Error handling

The header file `ErrorHandling.hpp` is provided to manage errors in the code.
Three macros are defined:
        1. `PCMSOLVER_ERROR` this throws a C++ exception. The exception message
        contains the 5 most recent function calls. Use this to catch faulty data
        incoming to the API from the external world.
        2. `PCMSOLVER_ASSERT` this is a wrapper around the standard `assert`.
        Use it to catch your own errors, i.e. broken pre- or post-conditions to internal
        functions/classes. Assertions are **NOT** checked in release mode.
        3. `PCMSOLVER_STATIC_ASSERT` this is a static assertion, i.e. an assertion checked
        at compile-time. The usage pattern is the same as for `PCMSOLVER_ASSERT`.

### Proper overloading of operator<<

Suppose we have an inheritance hierarchy made of an abstract base class, Base, and
two derived classes, Derived1 and Derived2.
In the Base class header file we will define a pure virtual private function printObject
and provide a public friend overload of operator<<:

\code{.cpp}
    #include <iosfwd>

    class Base
    {
        public:
                // All your other very fancy public members
                friend std::ostream & operator<<(std::ostream & os, Base & base)
                {
                        return base.printObject(os);
                }
        protected:
                // All your other very fancy protected members
        private:
                // All your other very fancy private members
                virtual std::ostream & printObject(std::ostream & os) = 0;
    }
\endcode

The printObject method can also be made (impure) virtual, it really depends on your class hierarchy.
Derived1 and Derived2 header files will provide a public friend overload of operator<< (friendliness
isn't inherited, transitive or reciprocal) and an override for the printObject method:

\code{.cpp}
    #include <iosfwd>

    #include "Base.hpp"

    class Derived1 : public Base
    {
        public:
                // All your other very fancy public members
                friend std::ostream & operator<<(std::ostream & os, Derived1 & derived)
                {
                        return derived.printObject(os);
                }
        protected:
                // All your other very fancy protected members
        private:
                // All your other very fancy private members
                virtual std::ostream & printObject(std::ostream & os);
    }

    class Derived2 : public Base
    {
        public:
                // All your other very fancy public members
                friend std::ostream & operator<<(std::ostream & os, Derived2 & derived)
                {
                        return derived.printObject(os);
                }
        protected:
                // All your other very fancy protected members
        private:
                // All your other very fancy private members
                virtual std::ostream & printObject(std::ostream & os);
    }
\endcode

### Code formatting

We conform to the so-called Linux (aka kernel) formatting style for C/C++ code (see http://en.wikipedia.org/wiki/Indent_style#Kernel_style)
with minimal modifications. If uncertain on your code formatting use the Artistic Style command-line utility
to rectify it:

\code
   astyle --style=linux --max-code-length=85 --indent-namespaces --keep-one-line-blocks filename
\endcode


*/
