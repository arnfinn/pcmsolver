#!/bin/bash -l
set -e

#defaults
install_prefix=${install_prefix:="-DCMAKE_INSTALL_PREFIX=`pwd`"}
build_type=Debug
show=false

config_flags=""
enable_blas=false
enable_mpi=false
enable_omp=false
enable_cuda=false
enable_tests=false
enable_coverage=false
config_ok=false

usage() {
cat << EOF
 Usage: setup [options] 
   --prefix=DIR     Base install path
   --debug          Configure the debugging version in (defautlt)
   --release        Configure the fully optimized version
   --para           Enable the OpenMP + MPI parallel version
   --omp            Enable OpenMP
   --mpi            Enable MPI
   --cuda           Enable CUDA support
   --enable-tests   Enable unit testing
   --no-blas        Disable the BLAS back-end
   --help           Print this message
   --coverage       Compiler with code coverage
   --show          	Show cmake command line
   -D*              Any other options are passed directly to 'cmake'

 setup is a frontend to 'cmake'. It tries to automagically configure 
 some known standard and non-standard systems. If it fails, you must run 
 'ccmake' by hand.
EOF
exit 0
}

parse_command_line () {
	for i in $*; do
		case $i in
			--prefix=*) setup_install_prefix $i; shift ;;
			--debug) build_type=Debug; shift ;;
			--release) build_type=Release; shift ;;
			--para*) enable_mpi=true; enable_omp=true; shift ;;
			--omp) enable_omp=true; shift ;;
			--mpi) enable_mpi=true; shift ;;
			--cuda) enable_cuda=true; shift ;;
			--enable-tests) enable_tests=true; shift ;;
			--coverage) enable_coverage=true; shift ;;
			--no-blas|--disable-blas) enable_blas=false; shift ;;
			--enable-blas) enable_blas=true; shift ;;
			-D*) config_flags="$config_flags $i"; shift ;;
			--help|-h|-?) usage; shift ;;
			--show) show=true; shift ;;
			-*) echo "Invalid option: $i"; exit 1 ;;
		esac
	done
}

setup_install_prefix() {
	prefix="`echo $1 |sed 's/--prefix=//'`"
	install_prefix="-DCMAKE_INSTALL_PREFIX=$1"
}

setup_config_flags() {
	config_flags="$config_flags -DCMAKE_BUILD_TYPE=$build_type"

	if [ "x$EIGEN3_ROOT" != x ]; then 
		config_flags="$config_flags -DEIGEN3_ROOT=$EIGEN3_ROOT"
	fi
	
	if [ "x$BOOST_ROOT" != x ]; then
		config_flags="$config_flags -DBOOST_ROOT=$BOOST_ROOT"
	fi
	
	if [ "x$enable_tests" = "xtrue" ]; then
		config_flags="$config_flags -DENABLE_TESTS=ON"
	fi

	if [ "x$GTEST_ROOT" != x ]; then
		config_flags="$config_flags -DGTEST_ROOT=$GTEST_ROOT"
	fi

	if [ "x$enable_coverage" = "xtrue" ]; then
		config_flags="$config_flags -DENABLE_CODE_COVERAGE=ON"
	fi

	if [ "x$enable_mpi" = "xtrue" ]; then
		config_flags="$config_flags -DENABLE_MPI=ON"
		config_flags="$config_flags -DMPI_COMPILER=`which $CXX`"
	fi

	if [ "x$enable_omp" = "xtrue" ]; then
		config_flags="$config_flags -DENABLE_OPENMP=ON"
	fi

	if [ "x$enable_cuda" = "xtrue" ]; then
		config_flags="$config_flags -DENABLE_CUDA=ON"
	fi

	if [ "x$enable_blas" = "xtrue" ]; then
		setup_blas
	fi

}

setup_blas() {
	config_flags="$config_flags -DENABLE_BLAS=ON"
	if [ "x$BLAS_TYPE" != "x" ]; then 
		config_flags="$config_flags -DBLAS_TYPE=$BLAS_TYPE"
	fi
	if [ "x$BLAS_ROOT" != x ]; then 
		config_flags="$config_flags -DBLAS_ROOT=$BLAS_ROOT"
	fi
}

config_stallo() {
	module load boost >/dev/null 2>&1
	module load eigen/3.0.0 >/dev/null 2>&1
	module load google-test >/dev/null 2>&1
	CMAKE="$CMAKE_ROOT/bin/cmake"
	if [ "x$enable_mpi" = "xtrue" ]; then
		CXX=mpicxx
		CC=mpicc
		export MPIEXEC_PREFLAGS="--mca btl self,tcp"
	else
		CXX=${CXX:=icpc}
		CC=${CC:=icc}
	fi
	case $CXX in
		*g++) 
		module unload mkl
		module unload google-test
		module load atlas
		module load google-test/1.5.0_gcc
		BLAS_TYPE=Atlas
		BLAS_ROOT=${BLAS_ROOT:="$ATLAS_ROOT"}
		;;
		*) 
		BLAS_TYPE=MKL
		BLAS_ROOT=${BLAS_ROOT:="$MKL_ROOT"}
		;;
	esac	
	BOOST_ROOT=${BOOST_ROOT:="$BOOSTHOME"}
	enable_coverage=${enable_coverage:=false}
	config_ok=true
}

config_darwin_osx() {
	BOOST_ROOT=${BOOST_ROOT:="/opt/local"}
	if [ "x$enable_mpi" = "xtrue" ]; then
		CXX=mpic++
		CC=mpicc
		FC=mpif90
	fi
	config_ok=true
}

config_fedora() {
	if [ "x$enable_mpi" = "xtrue" ]; then
		CXX=mpic++
		CC=mpicc
		FC=mpif90
	fi
	config_ok=true
}

config_ubuntu() {
	EIGEN3_ROOT=${EIGEN3_ROOT:="/opt/eigen/3.0.0"}
	if [ "x$enable_mpi" = "xtrue" ]; then
		CXX=mpic++
		CC=mpicc
		FC=mpif90
	fi
	config_ok=true
}

try_config_host() {
	if [ "x$SETUP_HOST" = "xstallo" ]; then
		config_stallo 
		return
	fi
	case `hostname` in
		stallo*) config_stallo ;;
		c*-*) config_stallo ;;
	esac
}

try_config_os() {
	case `uname` in
		Linux*)

		case `lsb_release -si` in
			Ubuntu|Debian) config_ubuntu ;;
			Fedora|CentOS) config_fedora ;;
		esac
		;;
		Darwin) config_darwin_osx ;;
	esac
}

get_srcdir() {
	cd `dirname $0` >/dev/null 2>&1
	srcdir=`pwd` 
	cd - >/dev/null 2>&1
}

get_srcdir
parse_command_line $*

[ "${config_ok}" = "false" ] && try_config_host
[ "${config_ok}" = "false" ] && try_config_os
[ "${config_ok}" = "false" ] && echo "Unknown system, using generic setup"

setup_config_flags

buildenv=""
[ "x$CXX" != "x" ] && buildenv="$buildenv CXX=$CXX"
[ "x$CC" != "x" ] && buildenv="$buildenv CC=$CC"
[ "x$FC" != "x" ] && buildenv="$buildenv Fortran=$FC"

configure_cmd="$buildenv ${CMAKE:="cmake"} $install_prefix $config_flags"


if [ "$show" = "true" ]; then
	echo "$configure_cmd"
else
	eval "$configure_cmd $srcdir"
fi

